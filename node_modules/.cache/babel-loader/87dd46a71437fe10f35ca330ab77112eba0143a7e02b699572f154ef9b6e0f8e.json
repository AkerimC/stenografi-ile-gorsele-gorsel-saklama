{"ast":null,"code":"var _jsxFileName = \"/home/kerim/Belgeler/algoritma1/src/components/DecodeForm.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState } from 'react';\nimport UPNG from 'upng-js';\nimport ImageUploadBox from './ImageUploadBox';\nimport ImageDisplayBox from './ImageDisplayBox';\nimport './DecodeForm.css';\nimport { decodeWithSSS } from '../encodeWithSSS';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DecodeForm = () => {\n  _s();\n  const [inputImage1, setInputImage1] = useState(null);\n  const [inputImage2, setInputImage2] = useState(null);\n  const [inputImage3, setInputImage3] = useState(null);\n  const [decodedImage, setDecodedImage] = useState(null);\n\n  // These will store the STEGO IMAGE dimensions from the first uploaded image\n  const [stegoImgWidth, setStegoImgWidth] = useState(null);\n  const [stegoImgHeight, setStegoImgHeight] = useState(null);\n  const pixelArr = React.useRef([]);\n  const handleImage = file => {\n    if (!file) {\n      console.error(\"Dosya seçilmedi!\");\n      return;\n    }\n    const reader = new FileReader();\n    reader.onload = e => {\n      var _e$target;\n      if (!((_e$target = e.target) !== null && _e$target !== void 0 && _e$target.result)) return;\n      const arrayBuffer = e.target.result;\n      const png = UPNG.decode(arrayBuffer);\n\n      // Set stego dimensions from the first image, assume others are the same\n      if (pixelArr.current.length === 0) {\n        // Only set for the first image processed\n        setStegoImgWidth(png.width);\n        setStegoImgHeight(png.height);\n      }\n      // Use the state for consistent dimensions, especially if files are processed asynchronously\n      // For this function call, png.width and png.height are the current stego image's dimensions.\n      // We need the *original secret image's* dimensions to know how many bytes to extract.\n      // These are half of the stego image's dimensions.\n      const currentStegoWidth = png.width;\n      const currentStegoHeight = png.height;\n\n      // If stegoImgWidth is already set, we expect current stego image to match.\n      // This is a good place for a sanity check if needed:\n      // if (stegoImgWidth && (stegoImgWidth !== currentStegoWidth || stegoImgHeight !== currentStegoHeight)) {\n      //   console.warn(\"Stego images have different dimensions!\");\n      //   // Potentially handle this error\n      // }\n\n      const rawPixels = new Uint8Array(UPNG.toRGBA8(png)[0]);\n      const newImage = [[], []]; // [0] = imageNumber, [1] = share_bytes_array\n\n      const imageNumber = rawPixels[3] & 0b00000111;\n      console.log(`Processing share with image number (x-coordinate): ${imageNumber}`);\n      newImage[0].push(imageNumber);\n\n      // Determine dimensions of the ORIGINAL SECRET image\n      // This relies on stegoImgWidth/Height being set correctly (e.g., from the first image, or consistently)\n      // If stegoImgWidth is not yet set (first image), use current png.width/height\n      const effectiveStegoWidth = stegoImgWidth || currentStegoWidth;\n      const effectiveStegoHeight = stegoImgHeight || currentStegoHeight;\n      const originalSecretWidth = effectiveStegoWidth / 2;\n      const originalSecretHeight = effectiveStegoHeight / 2;\n      if (originalSecretWidth <= 0 || originalSecretHeight <= 0 || !Number.isInteger(originalSecretWidth) || !Number.isInteger(originalSecretHeight)) {\n        console.error(\"Could not determine valid original secret image dimensions. Stego dimensions might be odd or not set.\", {\n          effectiveStegoWidth,\n          effectiveStegoHeight\n        });\n        alert(\"Error: Could not determine original secret image dimensions. Stego image dimensions might be problematic.\");\n        return;\n      }\n      const numExpectedShareBytes = originalSecretWidth * originalSecretHeight * 3;\n      const numExpectedTwoBitChunks = numExpectedShareBytes * 4;\n      console.log(`Expecting to extract ${numExpectedShareBytes} share bytes (${numExpectedTwoBitChunks} 2-bit chunks) for original dimensions ${originalSecretWidth}x${originalSecretHeight}`);\n      const extractedTwoBitChunks = [];\n      let twoBitChunksCollected = 0;\n\n      // Iterate over stego-image pixels to collect 2-bit chunks\n      for (let i = 0; i < rawPixels.length && twoBitChunksCollected < numExpectedTwoBitChunks; i += 4) {\n        // Extract from R, G, B channels. Alpha (rawPixels[i+3]) is skipped for data,\n        // (except rawPixels[3] for imageNumber already handled).\n        if (twoBitChunksCollected < numExpectedTwoBitChunks) {\n          extractedTwoBitChunks.push(rawPixels[i] & 0b00000011);\n          twoBitChunksCollected++;\n        }\n        if (twoBitChunksCollected < numExpectedTwoBitChunks) {\n          extractedTwoBitChunks.push(rawPixels[i + 1] & 0b00000011);\n          twoBitChunksCollected++;\n        }\n        if (twoBitChunksCollected < numExpectedTwoBitChunks) {\n          extractedTwoBitChunks.push(rawPixels[i + 2] & 0b00000011);\n          twoBitChunksCollected++;\n        }\n      }\n      if (twoBitChunksCollected !== numExpectedTwoBitChunks) {\n        console.warn(`Expected ${numExpectedTwoBitChunks} 2-bit chunks, but collected ${twoBitChunksCollected}. This might lead to errors.`);\n        // You might want to alert the user or stop if this happens, as it indicates a mismatch.\n      }\n\n      // Reconstruct share bytes from the collected 2-bit chunks\n      for (let j = 0; j < extractedTwoBitChunks.length; j += 4) {\n        if (j + 3 < extractedTwoBitChunks.length) {\n          // Ensure we have 4 chunks to form a byte\n          const byteValue = extractedTwoBitChunks[j] << 6 | extractedTwoBitChunks[j + 1] << 4 | extractedTwoBitChunks[j + 2] << 2 | extractedTwoBitChunks[j + 3];\n          newImage[1].push(byteValue);\n        } else {\n          // This should only happen if extractedTwoBitChunks.length is not a multiple of 4.\n          // Given the check above, if numExpectedTwoBitChunks was met, this part might be less critical,\n          // but it's a safeguard.\n          console.warn(\"Partial byte at the end of 2-bit chunk stream. Data might be truncated or misaligned.\");\n          break;\n        }\n      }\n      console.log(`Extracted ${newImage[1].length} share bytes for image number ${imageNumber}. First few:`, newImage[1].slice(0, 10));\n      pixelArr.current.push(newImage);\n\n      // Optional: Display the extracted share (as a grayscale or using a placeholder)\n      // This part was commented out, but useful for debugging individual share extraction\n      /*\n      const share_rgba = new Uint8Array(originalSecretWidth * originalSecretHeight * 4);\n      for (let k = 0, m = 0; k < newImage[1].length && m < share_rgba.length; k += 3, m += 4) {\n        share_rgba[m] = newImage[1][k];     // R\n        share_rgba[m+1] = newImage[1][k+1] !== undefined ? newImage[1][k+1] : newImage[1][k]; // G (or R if no G)\n        share_rgba[m+2] = newImage[1][k+2] !== undefined ? newImage[1][k+2] : newImage[1][k]; // B (or R if no B)\n        share_rgba[m+3] = 255;             // Alpha\n      }\n      const share_pngData = UPNG.encode([share_rgba.buffer], originalSecretWidth, originalSecretHeight, 0);\n      const share_blob = new Blob([share_pngData], { type: \"image/png\" });\n      const share_url = URL.createObjectURL(share_blob);\n      // You'd need a way to display this, e.g., setInputImage1(share_url) IF it's the first image.\n      // This is just for debugging one share.\n      */\n    };\n    reader.onerror = error => {\n      console.error('Dosya okuma hatası:', error);\n      alert('Dosya okuma hatası oluştu!');\n    };\n    reader.readAsArrayBuffer(file);\n  };\n  const handleDecode = () => {\n    if (pixelArr.current.length < 3) {\n      // Make sure we have at least 3 shares\n      alert('Lütfen decode için en az 3 resmi de yükleyin.');\n      return;\n    }\n    if (!inputImage1 || !inputImage2 || !inputImage3) {\n      // Check if the UI shows 3 images\n      alert('Lütfen decode için 3 resmi de yükleyin (UI kontrolü).');\n      return;\n    }\n    if (!stegoImgWidth || !stegoImgHeight) {\n      alert(\"Stego image dimensions not set. Please upload images again.\");\n      return;\n    }\n\n    // Ensure all share arrays have the same length\n    const firstShareLength = pixelArr.current[0][1].length;\n    for (let i = 1; i < pixelArr.current.length; i++) {\n      if (pixelArr.current[i][1].length !== firstShareLength) {\n        console.error(\"Mismatch in share data lengths:\", pixelArr.current.map(p => p[1].length));\n        alert(\"Hata: Paylaşılan veri uzunlukları eşleşmiyor! Yeniden yüklemeyi deneyin.\");\n        return;\n      }\n    }\n    console.log(\"Decoding with shares:\", JSON.parse(JSON.stringify(pixelArr.current.map(p => ({\n      x: p[0][0],\n      y_length: p[1].length,\n      y_sample: p[1].slice(0, 5)\n    })))));\n    const finalImageBytes = decodeWithSSS(pixelArr.current); // Ensure pixelArr.current is correctly structured for this\n\n    const originalSecretWidth = stegoImgWidth / 2;\n    const originalSecretHeight = stegoImgHeight / 2;\n    console.log(`Reconstructed ${finalImageBytes.length} total bytes. Expected for ${originalSecretWidth}x${originalSecretHeight} image: ${originalSecretWidth * originalSecretHeight * 3} bytes.`);\n    if (finalImageBytes.length !== originalSecretWidth * originalSecretHeight * 3) {\n      console.error(\"Decoded byte count mismatch!\");\n      alert(\"Hata: Decode edilen veri boyutu beklenenden farklı. Sonuç hatalı olabilir.\");\n      // Decide whether to proceed or not\n    }\n    const rgba = new Uint8Array(originalSecretWidth * originalSecretHeight * 4);\n    for (let i = 0, j = 0; i < finalImageBytes.length && j < rgba.length; i += 3, j += 4) {\n      rgba[j] = finalImageBytes[i]; // R\n      rgba[j + 1] = finalImageBytes[i + 1]; // G\n      rgba[j + 2] = finalImageBytes[i + 2]; // B\n      rgba[j + 3] = 255; // A (tam opak)\n    }\n    const pngData = UPNG.encode([rgba.buffer], originalSecretWidth, originalSecretHeight, 0);\n    const blob = new Blob([pngData], {\n      type: \"image/png\"\n    });\n    const url = URL.createObjectURL(blob);\n    setDecodedImage(url);\n    console.log(\"Decode işlemi tamamlandı!\");\n  };\n\n  // ... rest of the component (return statement with JSX)\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"decode-form\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"decode-section section-inputs\",\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Decode Edilecek Resimler\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 211,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"decode-input-grid\",\n        children: [/*#__PURE__*/_jsxDEV(ImageUploadBox, {\n          label: \"Resim 1\",\n          onImageUpload: file => {\n            handleImage(file);\n            setInputImage1(file ? URL.createObjectURL(file) : null);\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 213,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(ImageUploadBox, {\n          label: \"Resim 2\",\n          onImageUpload: file => {\n            handleImage(file);\n            setInputImage2(file ? URL.createObjectURL(file) : null);\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 218,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(ImageUploadBox, {\n          label: \"Resim 3\",\n          onImageUpload: file => {\n            handleImage(file);\n            setInputImage3(file ? URL.createObjectURL(file) : null);\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 223,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 212,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleDecode,\n        className: \"decode-action-button\",\n        disabled: !inputImage1 || !inputImage2 || !inputImage3 || pixelArr.current.length < 3,\n        children: \"Decode Et\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 229,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 210,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"decode-section section-output\",\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Decode Edilmi\\u015F Resim\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 236,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ImageDisplayBox, {\n        imageSrc: decodedImage || 'https://via.placeholder.com/250/DDDDDD/000000?Text=SonuçBurada',\n        altText: \"Decode Edilmi\\u015F Sonu\\xE7\",\n        className: \"decoded-image-display\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 237,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 235,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 208,\n    columnNumber: 5\n  }, this);\n};\n_s(DecodeForm, \"Q3N/64f5RleD0n+IxSrDpKWREPU=\");\n_c = DecodeForm;\nexport default DecodeForm;\nvar _c;\n$RefreshReg$(_c, \"DecodeForm\");","map":{"version":3,"names":["React","useRef","useState","UPNG","ImageUploadBox","ImageDisplayBox","decodeWithSSS","jsxDEV","_jsxDEV","DecodeForm","_s","inputImage1","setInputImage1","inputImage2","setInputImage2","inputImage3","setInputImage3","decodedImage","setDecodedImage","stegoImgWidth","setStegoImgWidth","stegoImgHeight","setStegoImgHeight","pixelArr","handleImage","file","console","error","reader","FileReader","onload","e","_e$target","target","result","arrayBuffer","png","decode","current","length","width","height","currentStegoWidth","currentStegoHeight","rawPixels","Uint8Array","toRGBA8","newImage","imageNumber","log","push","effectiveStegoWidth","effectiveStegoHeight","originalSecretWidth","originalSecretHeight","Number","isInteger","alert","numExpectedShareBytes","numExpectedTwoBitChunks","extractedTwoBitChunks","twoBitChunksCollected","i","warn","j","byteValue","slice","onerror","readAsArrayBuffer","handleDecode","firstShareLength","map","p","JSON","parse","stringify","x","y_length","y_sample","finalImageBytes","rgba","pngData","encode","buffer","blob","Blob","type","url","URL","createObjectURL","className","children","fileName","_jsxFileName","lineNumber","columnNumber","label","onImageUpload","onClick","disabled","imageSrc","altText","_c","$RefreshReg$"],"sources":["/home/kerim/Belgeler/algoritma1/src/components/DecodeForm.js"],"sourcesContent":["import React, { useRef, useState } from 'react';\nimport UPNG from 'upng-js';\nimport ImageUploadBox from './ImageUploadBox';\nimport ImageDisplayBox from './ImageDisplayBox';\nimport './DecodeForm.css';\nimport { decodeWithSSS } from '../encodeWithSSS';\n\n\nconst DecodeForm = () => {\n  const [inputImage1, setInputImage1] = useState(null);\n  const [inputImage2, setInputImage2] = useState(null);\n  const [inputImage3, setInputImage3] = useState(null);\n  const [decodedImage, setDecodedImage] = useState(null);\n  \n  // These will store the STEGO IMAGE dimensions from the first uploaded image\n  const [stegoImgWidth, setStegoImgWidth] = useState(null);\n  const [stegoImgHeight, setStegoImgHeight] = useState(null);\n  \n  const pixelArr = React.useRef([]);\n\n  const handleImage = (file) => {\n    if (!file) {\n      console.error(\"Dosya seçilmedi!\");\n      return;\n    }\n    const reader = new FileReader();\n    \n    reader.onload = (e) => {\n      if (!e.target?.result) return;\n      const arrayBuffer = e.target.result;\n      const png = UPNG.decode(arrayBuffer);\n\n      // Set stego dimensions from the first image, assume others are the same\n      if (pixelArr.current.length === 0) { // Only set for the first image processed\n        setStegoImgWidth(png.width);\n        setStegoImgHeight(png.height);\n      }\n      // Use the state for consistent dimensions, especially if files are processed asynchronously\n      // For this function call, png.width and png.height are the current stego image's dimensions.\n      // We need the *original secret image's* dimensions to know how many bytes to extract.\n      // These are half of the stego image's dimensions.\n      const currentStegoWidth = png.width;\n      const currentStegoHeight = png.height;\n\n      // If stegoImgWidth is already set, we expect current stego image to match.\n      // This is a good place for a sanity check if needed:\n      // if (stegoImgWidth && (stegoImgWidth !== currentStegoWidth || stegoImgHeight !== currentStegoHeight)) {\n      //   console.warn(\"Stego images have different dimensions!\");\n      //   // Potentially handle this error\n      // }\n\n\n      const rawPixels = new Uint8Array(UPNG.toRGBA8(png)[0]);\n      const newImage = [[], []]; // [0] = imageNumber, [1] = share_bytes_array\n      \n      const imageNumber = rawPixels[3] & 0b00000111;\n      console.log(`Processing share with image number (x-coordinate): ${imageNumber}`);\n      newImage[0].push(imageNumber);\n\n      // Determine dimensions of the ORIGINAL SECRET image\n      // This relies on stegoImgWidth/Height being set correctly (e.g., from the first image, or consistently)\n      // If stegoImgWidth is not yet set (first image), use current png.width/height\n      const effectiveStegoWidth = stegoImgWidth || currentStegoWidth;\n      const effectiveStegoHeight = stegoImgHeight || currentStegoHeight;\n\n      const originalSecretWidth = effectiveStegoWidth / 2;\n      const originalSecretHeight = effectiveStegoHeight / 2;\n\n      if (originalSecretWidth <= 0 || originalSecretHeight <= 0 || !Number.isInteger(originalSecretWidth) || !Number.isInteger(originalSecretHeight) ) {\n          console.error(\"Could not determine valid original secret image dimensions. Stego dimensions might be odd or not set.\",\n                        {effectiveStegoWidth, effectiveStegoHeight});\n          alert(\"Error: Could not determine original secret image dimensions. Stego image dimensions might be problematic.\");\n          return;\n      }\n\n      const numExpectedShareBytes = originalSecretWidth * originalSecretHeight * 3;\n      const numExpectedTwoBitChunks = numExpectedShareBytes * 4;\n      \n      console.log(`Expecting to extract ${numExpectedShareBytes} share bytes (${numExpectedTwoBitChunks} 2-bit chunks) for original dimensions ${originalSecretWidth}x${originalSecretHeight}`);\n\n      const extractedTwoBitChunks = [];\n      let twoBitChunksCollected = 0;\n\n      // Iterate over stego-image pixels to collect 2-bit chunks\n      for (let i = 0; i < rawPixels.length && twoBitChunksCollected < numExpectedTwoBitChunks; i += 4) {\n        // Extract from R, G, B channels. Alpha (rawPixels[i+3]) is skipped for data,\n        // (except rawPixels[3] for imageNumber already handled).\n        if (twoBitChunksCollected < numExpectedTwoBitChunks) {\n          extractedTwoBitChunks.push(rawPixels[i] & 0b00000011);\n          twoBitChunksCollected++;\n        }\n        if (twoBitChunksCollected < numExpectedTwoBitChunks) {\n          extractedTwoBitChunks.push(rawPixels[i + 1] & 0b00000011);\n          twoBitChunksCollected++;\n        }\n        if (twoBitChunksCollected < numExpectedTwoBitChunks) {\n          extractedTwoBitChunks.push(rawPixels[i + 2] & 0b00000011);\n          twoBitChunksCollected++;\n        }\n      }\n      \n      if (twoBitChunksCollected !== numExpectedTwoBitChunks) {\n          console.warn(`Expected ${numExpectedTwoBitChunks} 2-bit chunks, but collected ${twoBitChunksCollected}. This might lead to errors.`);\n          // You might want to alert the user or stop if this happens, as it indicates a mismatch.\n      }\n\n      // Reconstruct share bytes from the collected 2-bit chunks\n      for (let j = 0; j < extractedTwoBitChunks.length; j += 4) {\n        if (j + 3 < extractedTwoBitChunks.length) { // Ensure we have 4 chunks to form a byte\n          const byteValue = (extractedTwoBitChunks[j] << 6 |\n                             extractedTwoBitChunks[j + 1] << 4 |\n                             extractedTwoBitChunks[j + 2] << 2 |\n                             extractedTwoBitChunks[j + 3]);\n          newImage[1].push(byteValue);\n        } else {\n          // This should only happen if extractedTwoBitChunks.length is not a multiple of 4.\n          // Given the check above, if numExpectedTwoBitChunks was met, this part might be less critical,\n          // but it's a safeguard.\n          console.warn(\"Partial byte at the end of 2-bit chunk stream. Data might be truncated or misaligned.\");\n          break; \n        }\n      }\n      \n      console.log(`Extracted ${newImage[1].length} share bytes for image number ${imageNumber}. First few:`, newImage[1].slice(0, 10));\n      pixelArr.current.push(newImage);\n\n      // Optional: Display the extracted share (as a grayscale or using a placeholder)\n      // This part was commented out, but useful for debugging individual share extraction\n      /*\n      const share_rgba = new Uint8Array(originalSecretWidth * originalSecretHeight * 4);\n      for (let k = 0, m = 0; k < newImage[1].length && m < share_rgba.length; k += 3, m += 4) {\n        share_rgba[m] = newImage[1][k];     // R\n        share_rgba[m+1] = newImage[1][k+1] !== undefined ? newImage[1][k+1] : newImage[1][k]; // G (or R if no G)\n        share_rgba[m+2] = newImage[1][k+2] !== undefined ? newImage[1][k+2] : newImage[1][k]; // B (or R if no B)\n        share_rgba[m+3] = 255;             // Alpha\n      }\n      const share_pngData = UPNG.encode([share_rgba.buffer], originalSecretWidth, originalSecretHeight, 0);\n      const share_blob = new Blob([share_pngData], { type: \"image/png\" });\n      const share_url = URL.createObjectURL(share_blob);\n      // You'd need a way to display this, e.g., setInputImage1(share_url) IF it's the first image.\n      // This is just for debugging one share.\n      */\n\n    };\n    reader.onerror = (error) => {\n      console.error('Dosya okuma hatası:', error);\n      alert('Dosya okuma hatası oluştu!');\n    };\n    reader.readAsArrayBuffer(file);\n  };\n\n  const handleDecode = () => {\n    if (pixelArr.current.length < 3) { // Make sure we have at least 3 shares\n        alert('Lütfen decode için en az 3 resmi de yükleyin.');\n        return;\n    }\n    if (!inputImage1 || !inputImage2 || !inputImage3) { // Check if the UI shows 3 images\n      alert('Lütfen decode için 3 resmi de yükleyin (UI kontrolü).');\n      return;\n    }\n    if (!stegoImgWidth || !stegoImgHeight) {\n        alert(\"Stego image dimensions not set. Please upload images again.\");\n        return;\n    }\n\n    // Ensure all share arrays have the same length\n    const firstShareLength = pixelArr.current[0][1].length;\n    for(let i = 1; i < pixelArr.current.length; i++) {\n        if (pixelArr.current[i][1].length !== firstShareLength) {\n            console.error(\"Mismatch in share data lengths:\", pixelArr.current.map(p => p[1].length));\n            alert(\"Hata: Paylaşılan veri uzunlukları eşleşmiyor! Yeniden yüklemeyi deneyin.\");\n            return;\n        }\n    }\n\n    console.log(\"Decoding with shares:\", JSON.parse(JSON.stringify(pixelArr.current.map(p => ({ x: p[0][0], y_length: p[1].length, y_sample: p[1].slice(0,5) })))));\n\n    const finalImageBytes = decodeWithSSS(pixelArr.current); // Ensure pixelArr.current is correctly structured for this\n    \n    const originalSecretWidth = stegoImgWidth / 2;\n    const originalSecretHeight = stegoImgHeight / 2;\n\n    console.log(`Reconstructed ${finalImageBytes.length} total bytes. Expected for ${originalSecretWidth}x${originalSecretHeight} image: ${originalSecretWidth * originalSecretHeight * 3} bytes.`);\n\n    if (finalImageBytes.length !== originalSecretWidth * originalSecretHeight * 3) {\n        console.error(\"Decoded byte count mismatch!\");\n        alert(\"Hata: Decode edilen veri boyutu beklenenden farklı. Sonuç hatalı olabilir.\");\n        // Decide whether to proceed or not\n    }\n\n    const rgba = new Uint8Array(originalSecretWidth * originalSecretHeight * 4);\n    for (let i = 0, j = 0; i < finalImageBytes.length && j < rgba.length; i += 3, j += 4) {\n      rgba[j] = finalImageBytes[i];       // R\n      rgba[j + 1] = finalImageBytes[i+1]; // G\n      rgba[j + 2] = finalImageBytes[i+2]; // B\n      rgba[j + 3] = 255;                  // A (tam opak)\n    }\n    \n    const pngData = UPNG.encode([rgba.buffer], originalSecretWidth, originalSecretHeight, 0);\n    const blob = new Blob([pngData], { type: \"image/png\" });\n    const url = URL.createObjectURL(blob);\n    setDecodedImage(url);\n    console.log(\"Decode işlemi tamamlandı!\");\n  };\n\n  // ... rest of the component (return statement with JSX)\n  return (\n    <div className=\"decode-form\">\n      {/* 1. Parça - Resim Inputları */}\n      <div className=\"decode-section section-inputs\">\n        <h3>Decode Edilecek Resimler</h3>\n        <div className=\"decode-input-grid\">\n          <ImageUploadBox\n            label=\"Resim 1\"\n            onImageUpload={(file) => {handleImage(file);\n              setInputImage1(file ? URL.createObjectURL(file) : null)}}\n          />\n          <ImageUploadBox\n            label=\"Resim 2\"\n            onImageUpload={(file) => {handleImage(file);\n              setInputImage2(file ? URL.createObjectURL(file) : null)}}\n          />\n          <ImageUploadBox\n            label=\"Resim 3\"\n            onImageUpload={(file) => {handleImage(file);\n              setInputImage3(file ? URL.createObjectURL(file) : null)}}\n          />\n        </div>\n        <button onClick={handleDecode} className=\"decode-action-button\" disabled={!inputImage1 || !inputImage2 || !inputImage3 || pixelArr.current.length < 3}>\n          Decode Et\n        </button>\n      </div>\n\n      {/* 2. Parça - Tek Resim Kutucuğu (Sonuç) */}\n      <div className=\"decode-section section-output\">\n        <h3>Decode Edilmiş Resim</h3>\n        <ImageDisplayBox\n          imageSrc={decodedImage || 'https://via.placeholder.com/250/DDDDDD/000000?Text=SonuçBurada'}\n          altText=\"Decode Edilmiş Sonuç\"\n          className=\"decoded-image-display\"\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default DecodeForm;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"const mod = 251;\nfunction modInverse(a, m) {\n  a = (a % m + m) % m;\n  for (let x = 1; x < m; x++) {\n    if (a * x % m === 1) {\n      return x;\n    }\n  }\n  throw new Error(`Modular inverse does not exist for ${a} mod ${m}`);\n}\nexport function encodeWithSSS(number) {\n  const Codes = [];\n  if (number > 250) {\n    number = 250;\n  }\n  function createF(number, x) {\n    return (number + 166 * x + 94 * x * x) % mod;\n  }\n  for (let i = 1; i <= 6; i++) {\n    Codes.push(i, createF(number, i));\n  }\n\n  //console.log(\"Codes: \", Codes);\n  return Codes;\n}\nexport function decodeWithSSS(Codes) {\n  function createPolinom(x, y, z) {\n    const lagrangePolynomial = [];\n    const denom = modInverse((x - y) * (x - z), mod);\n    lagrangePolynomial.push(denom % mod);\n    lagrangePolynomial.push((-y * denom + -z * denom) % mod);\n    lagrangePolynomial.push(-y * -z * denom % mod);\n    return lagrangePolynomial;\n  }\n  const l0 = createPolinom(Codes[0][0], Codes[2][0], Codes[4][0]);\n  const l1 = createPolinom(Codes[2][0], Codes[0][0], Codes[4][0]);\n  const l2 = createPolinom(Codes[4][0], Codes[0][0], Codes[2][0]);\n  const sum = [];\n  for (let i = 0; i < Codes[0][1].lenght; i++) {\n    //sum.push((l0[0] * Codes[0][1] + l1[0] * Codes[2][1] + l2[0] * Codes[4][1]) % mod);\n    //sum.push((l0[1] * Codes[0][1] + l1[1] * Codes[2][1] + l2[1] * Codes[4][1]) % mod);\n    sum.push((l0[2] * Codes[0][1] + l1[2] * Codes[2][1] + l2[2] * Codes[4][1]) % mod);\n  }\n  const normalized = sum.map(c => (c % mod + mod) % mod);\n  console.log(\"normalized: \", normalized);\n  return sum;\n}","map":{"version":3,"names":["mod","modInverse","a","m","x","Error","encodeWithSSS","number","Codes","createF","i","push","decodeWithSSS","createPolinom","y","z","lagrangePolynomial","denom","l0","l1","l2","sum","lenght","normalized","map","c","console","log"],"sources":["/home/kerim/Belgeler/algoritma1/src/encodeWithSSS.js"],"sourcesContent":["const mod =251;\n\nfunction modInverse(a, m) {\n    a = ((a % m) + m) % m;\n    for (let x = 1; x < m; x++) {\n        if ((a * x) % m === 1) {\n            return x;\n        }\n    }\n    throw new Error(`Modular inverse does not exist for ${a} mod ${m}`);\n}\n\nexport function encodeWithSSS(number){\n    const Codes=[]\n\n\n    if (number >250) {\n        number = 250;\n    }\n\n\n    \n    function createF(number,x){\n        return ((number+166*x+94*x*x) %mod);\n    }\n\n    for (let i=1;i<=6;i++){\n        Codes.push(i,createF(number,i));\n    }\n\n    //console.log(\"Codes: \", Codes);\n    return Codes;\n}\n\nexport function decodeWithSSS(Codes){\n\n    function createPolinom(x, y, z) {\n        const lagrangePolynomial = [];\n        const denom = modInverse((x - y) * (x - z), mod);\n        \n        lagrangePolynomial.push((denom) % mod);\n        lagrangePolynomial.push(((-y*denom)+(-z*denom)) % mod);\n        lagrangePolynomial.push(((-y * -z) * denom) % mod);\n        return lagrangePolynomial;\n    }\n    const l0=createPolinom(Codes[0][0],Codes[2][0],Codes[4][0]);\n    const l1=createPolinom(Codes[2][0],Codes[0][0],Codes[4][0]);\n    const l2=createPolinom(Codes[4][0],Codes[0][0],Codes[2][0]);\n\n    const sum=[];\n    for(let i=0;i<Codes[0][1].lenght;i++){\n        //sum.push((l0[0] * Codes[0][1] + l1[0] * Codes[2][1] + l2[0] * Codes[4][1]) % mod);\n        //sum.push((l0[1] * Codes[0][1] + l1[1] * Codes[2][1] + l2[1] * Codes[4][1]) % mod);\n        sum.push((l0[2] * Codes[0][1] + l1[2] * Codes[2][1] + l2[2] * Codes[4][1]) % mod);\n    }\n    const normalized = sum.map(c => ((c % mod) + mod) % mod);\n    console.log(\"normalized: \", normalized);\n\n    return sum;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}